# **实验一	汇编语言程序上机过程**

## 一）实验目的

- 学会安装“16位汇编程序开发软件”的安装，完成将汇编语言源程序录入进计算机、利用ml.exe进行汇编，LINK进行链接，并用DEBUG调试16位程序的全部过程。本实验大家不必了解程序细节，只是为了熟悉开发环境和上机过程。

## 二）实验内容

> 写16位汇编程序，从键盘输入一个字符串，然后换行后将该字符串输出到屏幕。

1. 源程序

```assembly
.8086
.MODEL SMALL
.DATA
ORG 100H;CS起始地址
STR DB 20,0,20 DUP(20H);字符串STR
.CODE
START:
	MOV AX,@DATA
	MOV DS,AX;数据段地址
	LEA DX,STR;将STR的相对于数据段首地址的偏移地址放进DX
	MOV AH,0AH
	INT 21H;从键盘输入一个字符串
	
	MOV DL,0AH
	MOV AH,02
	INT 21H;输出DL中的换行
	MOV DL,0DH
	MOV AH,02
	INT 21H;输出回车
	
	MOV BL,STR[1]
	MOV BH,0;BX=20
	MOV BYTE PTR STR[BX+2],'$';末尾加'$'
	LEA DX,STR+2
	MOV AH,9
	INT 21H;输出这一句话
	MOV AH,4CH
	INT 21H;返回DOS
END START
```

2. 运行结果贴图

![](https://raw.githubusercontent.com/ZizhuoWang/AssemblyExperiment/master/2/2.png)

3. 编程与调试心得（遇到的问题和解决的办法，以及获得的收获）

> `INT 21`的9号调用输出以DS:DX为首地址，"\$"为结尾的字符串到显示器中。若要在显示字符串光标自动回车换行，则在"$"字符前面加上0DH(回车),0AH(换行)字符。

# **实验二	顺序程序设计**

## 一）实验目的

>  通过这一部分的实验，进一步熟悉汇编过程和DEBUG调试过程；掌握用汇编语言编写顺序程序。

## 二）实验内容

> 写完整程序16位程序，在内存中从Table开始的10个单元中连续存放0到9的平方值，任给一个0到9的数X，该数存放在内存单元XX中，用XLAT指令查表求X的平方值，并将结果存于内存YY单元中。编写程序，并在DEBUG中进行调试和验证结果。(X，XX，YY都是内存中的变量）

1. 源程序

```assembly
.8086
.MODEL SMALL
.STACK
.DATA
    Table BYTE 0,1,4,9,16,25,36,49,64,81
    XX BYTE 9
    YY BYTE ?
.CODE
START:
    MOV AX,@DATA
    MOV DS,AX
    LEA BX,Table
    MOV AL,XX
    XLAT;以DS:[BX+AL]为地址，提取存储器中的一个字节再送入AL。
    MOV YY,AL
END START
```

2. 运行结果贴图

![](https://raw.githubusercontent.com/ZizhuoWang/AssemblyExperiment/master/3/31.png)

可以看到DS:000A放的是09H，查找后AL中放的是51H=81D，存入YY=DS:000B中。

3. 编程与调试心得（遇到的问题和解决的办法，以及获得的收获）

> XLAT的指令功能：把待查表格的一个字节内容送到AL累加器中。在执行该指令前，应将Table先送至BX寄存器中，然后将待查字节与其在表格中距表首地址位移量送AL,即AL<--((BX)+(AL)). 执行XLAT将使待查内容送到累加器。

# **实验三	分支程序设计**

## 一）实验目的

> 通过本实验，熟练运算类指令对标志位状态的影响，以及标志位状态的表示方法；掌握无条件转移、条件转移指令的使用方法；掌握分支程序设计和调试方法。

## 二）实验内容

> 所谓回文字符串是指一个字符串正读和倒读都是一样的，例如字符串‘ABCDEFFEDCBA’就是一个回文字符串，而字符串‘ABCFDDCAB’就不是回文字符串。现在编写完整的16位汇编程序，输入一个字符串，判断该字符串是否为回文字符串，并用“It is a palindrome”或“It is NOT a palindrome”作为输出。

1. 源程序

```assembly
.8086
.MODEL SMALL
.STACK
.DATA
    N EQU 20
    MAXLEN BYTE N
    ACTLEN BYTE ?
    STRING BYTE N DUP('$');全部初始化成'$'
    TRUE BYTE 'It is a palindrome',0AH,0DH,'$';是
    FALSE BYTE 'It is NOT a palindrome',0AH,0DH,'$';不是
    CR BYTE 0AH,0DH;回车换行
.CODE
START:
    MOV AX,@DATA
    MOV DS,AX
    MOV AH,0AH
    MOV DX,OFFSET MAXLEN
    INT 21H;缓冲区的第一个字节指定容纳的最大字符个数，由用户给出；第二个字节存放实际的字符个数，由系统最后填入；从第三个字节开始存放从键盘接受的字符
    MOV AL,ACTLEN;实际的字符个数给AL
    MOV AH,0;清空AH
    MOV BL,2
    DIV BL;AH/2
    ADD AL,AH;加上余数
    MOV AH,0
    MOV BL,ACTLEN
    MOV BH,0
    MOV SI,BX
    MOV BX,OFFSET STRING
    DEC SI
LP: CMP SI,AX
    JNA T
    MOV DL,[BX+SI]
    MOV DH,[BX]
    CMP DL,DH
    JNZ F
    INC BX
    SUB SI,2
    JMP LP
T:  MOV DX,OFFSET TRUE
    JMP QUIT
F:  MOV DX,OFFSET FALSE
    JMP QUIT
QUIT:
    MOV AH,09H
    INT 21H
    MOV AH,4CH
    INT 21H
END START
```

